import struct

HEADER_FORMAT = '!Bi'
HEADER_SIZE = struct.calcsize(HEADER_FORMAT)


# format: 
SUBSCRIBE_MESSAGE = 1  # Sent by client to subscribe
# [SUBSCRIBE_MESSAGE]
# Server responses:
    # [SUBSCRIBE_ACK_MESSAGE][ClientID], where ClientID is autogenerated by server
    # [ERROR][TOO_MANY_CLIENTS], error code where client is unable to subscribe
SUBSCRIBE_ACK_MESSAGE = 2  # Sent by server to ack subscribe
# [SUBSCRIBE_ACK_MESSAGE][ClientID], where ClientID is autogenerated by server
JOB_READY = 3  # Sent by server to tell client a job is ready
# [JOB_READY][JobID], JobID unique to job
JOB_READY_TO_RECEIVE = 4  # Sent by client to acknowledge job ready, ready to receive job
# [JOB_READY_TO_RECEIVE][ClientID][JobID], ACKs job ID
RESUBSCRIBE_MESSAGE = 5 # Sent by client that was temporarily disconnected to reconnect
# [RESUBSCRIBE_MESSAGE][ClientID]
# Server responses:
    # [SUBSCRIBE_ACK_MESSAGE][ClientID]
    # [ERROR][NAME_ACTIVE], sent by server to client that is resubscribing to a name it considers actively connected
    # [ERROR][TOO_MANY_CLIENTS], sent by server if it already has enough clients
DATAFILE = 6 # Sent by server to client to give it the data for the current job
# [DATAFILE][ClientID][Filename][SeqNo]
# Client is responsible for writing the data to a file in order
DATAFILE_ACK = 7 # Sent by client to server to ACK  data
# [DATAFILE_ACK][ClientID][Filename][SeqNo]
# Server can move on to next file when current file is done sending
JOB_START = 8 # Sent by server to client to tell client to begin job
# [JOB_START][ClientID][JobID]
# If client does not have data for current job it will send an error
JOB_START_ACK = 9 # Sent by client to server to notify job has begun
# [JOB_START_ACK][ClientID][JobID]
JOB_HEARTBEAT = 10 # Sent by client to server to periodically update server on job progress
# [JOB_HEARTBEAT][ClientID][JobID][SeqNo]

SERVER_ERROR = $!$!$!$!$!$!$!$!$
# [SERVER_ERROR][ERROR_CODE]
# Error can mean a variety of things, it is up to the error handler to interpret the error code
CLIENT_ERROR = $!$!$!$!$!$!$!$!$
# [CLIENT_ERROR][ClientID][ERROR_CODE]
# Additionally specified is the client ID



class Message(object):
    def __init__(self, m_type, body=None):
        self.m_type = m_type
        self.body = body

    def __str__(self):
        return '<Message: type={m_type} body={body}>'.format(m_type=self.m_type, body=self.body)

    def has_body(self):
        return self.body

    def get_header_for_send(self):
        return struct.pack(HEADER_FORMAT, self.m_type, len(self.body) if self.body else 0)

    def get_body_for_send(self):
        return struct.pack(str(len(self.body)) + 's', bytes(self.body, encoding='utf-8'))

    def is_type(self, m_type):
        return m_type == self.m_type


class SubscribeMessage(Message):
    def __init__(self):
        super().__init__(SUBSCRIBE_MESSAGE)


class SubscribeAckMessage(Message):
    def __init__(self):
        super().__init__(SUBSCRIBE_ACK_MESSAGE)